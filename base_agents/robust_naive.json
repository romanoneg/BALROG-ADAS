{
    "code": "import copy\nimport re\n\nfrom balrog.agents.base import BaseAgent\n\n\nclass RobustNaiveAgent(BaseAgent):\n    \"\"\"An agent that generates actions based on observations without complex reasoning.\"\"\"\n\n    def __init__(self, client_factory, prompt_builder):\n        \"\"\"Initialize the NaiveAgent with a client and prompt builder.\"\"\"\n        super().__init__(client_factory, prompt_builder)\n        self.client = client_factory()\n\n    def act(self, obs, prev_action=None):\n        \"\"\"Generate the next action based on the observation and previous action.\n\n        Args:\n            obs (dict): The current observation in the environment.\n            prev_action (str, optional): The previous action taken.\n\n        Returns:\n            str: The selected action from the LLM response.\n        \"\"\"\n        if prev_action:\n            self.prompt_builder.update_action(prev_action)\n\n        self.prompt_builder.update_observation(obs)\n\n        messages = self.prompt_builder.get_prompt()\n\n        # Updated instructions to require a very strict output format\n        naive_instruction = \"\"\"\nYou must choose exactly one of the listed actions and output it strictly in the following format:\n\n<|ACTION|>YOUR_CHOSEN_ACTION<|END|>\n\nReplace YOUR_CHOSEN_ACTION with the chosen action. Output no other text, explanation, or reasoning.\n\"\"\".strip()\n\n        if messages and messages[-1].role == \"user\":\n            messages[-1].content += \"\\n\\n\" + naive_instruction\n\n        response = self.client.generate(messages)\n        final_answer = self._extract_final_answer(response)\n        return final_answer\n\n    def _extract_final_answer(self, answer):\n        \"\"\"Extract the action from the completion by looking for <|ACTION|> and <|END|> tags.\n\n        Args:\n            answer (LLMResponse): The response from the LLM.\n\n        Returns:\n            LLMResponse: The sanitized response containing just the extracted action.\n        \"\"\"\n        completion_text = answer.completion\n        # Use a regex to find the text inside <|ACTION|> and <|END|>\n        match = re.search(r\"<\\|ACTION\\|>(.*?)<\\|END\\|>\", completion_text, re.DOTALL)\n        if match:\n            extracted_action = match.group(1).strip()\n        else:\n            # If no match is found, fallback to the original completion or handle as needed\n            extracted_action = completion_text.strip()\n\n        final_answer = copy.deepcopy(answer)\n        final_answer = final_answer._replace(completion=extracted_action)\n\n        return final_answer\n"
}