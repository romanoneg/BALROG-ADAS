{
    "code": "import copy\nimport re\n\nfrom balrog.agents.base import BaseAgent\nfrom balrog.client import LLMClientWrapper\n\n\nclass RobustCoTAgent(BaseAgent):\n    \"\"\"An agent that performs actions using a chain-of-thought reasoning process.\"\"\"\n\n    def __init__(self, client_factory: LLMClientWrapper, prompt_builder, config):\n        \"\"\"Initialize the ChainOfThoughtAgent with a client, prompt builder, and configuration.\n\n        Args:\n            client_factory (LLMClientWrapper): A factory for creating the LLM client instance.\n            prompt_builder (PromptBuilder): Object to build prompts for the agent.\n            config: Configuration object containing settings for the agent.\n        \"\"\"\n        super().__init__(client_factory, prompt_builder)\n        self.remember_cot = config.agent.remember_cot\n\n    def act(self, obs, prev_action=None):\n        \"\"\"Generate the next action using chain-of-thought reasoning based on the current observation.\n\n        Args:\n            obs (dict): The current observation in the environment.\n            prev_action (str, optional): The previous action taken.\n\n        Returns:\n            LLMResponse: The response containing the final selected action.\n        \"\"\"\n        if prev_action:\n            self.prompt_builder.update_action(prev_action)\n\n        self.prompt_builder.update_observation(obs)\n\n        messages = self.prompt_builder.get_prompt()\n\n        # Updated instructions: chain of thought + strict output format\n        cot_instructions = \"\"\"\nFirst, think about the best course of action.\nThen, you must choose exactly one of the listed actions and output it strictly in the following format:\n\n<|ACTION|>YOUR_CHOSEN_ACTION<|END|>\n\nReplace YOUR_CHOSEN_ACTION with the chosen action.\n        \"\"\".strip()\n\n        # Add the updated instructions to the last message\n        messages[-1].content += \"\\n\\n\" + cot_instructions\n\n        # Generate the CoT reasoning\n        cot_reasoning = self.client.generate(messages)\n\n        # Extract the final answer from the CoT reasoning\n        final_answer = self._extract_final_answer(cot_reasoning)\n\n        return final_answer\n\n    def _extract_final_answer(self, reasoning):\n        \"\"\"Extract the final action from the chain-of-thought reasoning response.\n\n        Args:\n            reasoning (LLMResponse): The response containing CoT reasoning and action.\n\n        Returns:\n            LLMResponse: The response with the extracted final action in `completion`\n                         and the entire chain-of-thought in `reasoning`.\n        \"\"\"\n        # Make a copy so we don't mutate the original\n        final_answer = copy.deepcopy(reasoning)\n\n        # Store the entire chain-of-thought (raw completion) in `reasoning`\n        final_answer = final_answer._replace(reasoning=reasoning.completion)\n\n        # Now parse the strict action format: <|ACTION|> ... <|END|>\n        completion_text = reasoning.completion\n        match = re.search(r\"<\\|ACTION\\|>(.*?)<\\|END\\|>\", completion_text, re.DOTALL)\n        if match:\n            extracted_action = match.group(1).strip()\n        else:\n            # Fallback to the entire completion if not matched\n            extracted_action = \"Failed to obtain a valid action from the reasoning.\"\n\n        # Replace the final `completion` with only the extracted action\n        final_answer = final_answer._replace(completion=extracted_action)\n\n        return final_answer\n"
}